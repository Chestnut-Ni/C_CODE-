#include<stdio.h>
#include<string.h>
//写一个判断大小端存储的函数
//int check_sys()
//{
//	int a=1;
//	char *p=(char*)&a;
//	if(*p==1)
//		return 1;
//	else
//		return 0;
//}
//优化
//int check_sys()
//{
//	int a=1;
//	char*p=(char*)&a;//char型一个字节再利用指针的解引用判断第一个字节
//	return *p;
//}
//int main()
//{
//	int ret=check_sys();
//	if(ret==1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

////输出什么？
//int main()
//{
//    char a= -1;
//    signed char b=-1;//a和b是一样的
//    unsigned char c=-1;
//    printf("a=%d,b=%d,c=%d\n",a,b,c);//%d打印十进制有符号数字
//	//-1 -1 255
//    return 0;
//}
////a=-1
////1000 0000 0000 0000 0000 0000 0000 0001
////1111 1111 1111 1111 1111 1111 1111 1110
////1111 1111 1111 1111 1111 1111 1111 1111
////存到char型的a中时只能存8个比特位 即
////1111 1111
////由于打印的是整型所以要进行整型提升即高位补符号位
////1111 1111 1111 1111 1111 1111 1111 1111(补码)
////算回原码后就是-1
//
//
////c=-1
////1111 1111(无符号数 高位1不代表符号位整型提升时直接补0)
////0000 0000 0000 0000 0000  0000 1111 1111（补码 但是高位为0说明为正数 正数的原反补相同）
////255

//int main()
//{
//    char a = -128;
//    printf("%u\n",a);//%u打印十进制无符号数字
//    return 0;
//}//-128//原码1000 0000 0000 0000 0000 0000 1000 0000//反码1111 1111 1111 1111 1111 1111 0111 1111//补码1111 1111 1111 1111 1111 1111 1000 0000//1000 0000//整型提升//补码1111 1111 1111 1111 1111 1111 1000 0000//%u打印无符号数字 则高位1就不是符号位//4,294,967,168
//int main()
//{
//    char a = 128;//127+1=-128
//    printf("%u\n",a);
//	return 0;
//}

//int main()
//{
//	unsigned int i;
//	for(i = 9; i >= 0; i--)
//	{
//		printf("%u\n",i);
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//    for(i=0; i<1000; i++)
//	{
//        a[i] = -1-i;
//	}
//	printf("%d",strlen(a));
//    return 0;
//}

//unsigned char i = 0;
//int main()
//{
//	for(i = 0;i<=255;i++)//255+1=0
//	{
//        printf("hello world\n");
//	}
//    return 0;
//}